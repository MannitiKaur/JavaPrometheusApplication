package com.app.prommonitor.service;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.Supplier;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import com.app.prommonitor.beans.Book;
import com.app.prommonitor.entity.BooksEntity;
import com.app.prommonitor.mapper.BookMapper;
import com.app.prommonitor.repository.BooksRepository;
import com.app.prommonitor.util.MetricUtil;

import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import io.micrometer.core.instrument.Timer;


@Service
public class BooksService extends MetricUtil{

    private final BooksRepository booksRepository;
    private final MeterRegistry meterRegistry;

    public BooksService(BooksRepository booksRepository, MeterRegistry meterRegistry) {
        this.booksRepository = booksRepository;
        this.meterRegistry = meterRegistry;

        Supplier<Number> totalBooks = () -> Math.toIntExact(booksRepository.findAll().stream().count());
        
        // Method booksRepository Total Books Available will be executed every 15s - Prometheus scrape_interval setting
        Gauge.builder(MetricUtil.METRIC_BOOKS_IN_STORE_COUNT, totalBooks)
            .description("A current number of books in store")
            .register(meterRegistry);
        
        
        Gauge.builder(MetricUtil.METRIC_BOOKS_IN_STORE_COUNT, totalBooks)
        	.description("A current number of books in store")
        	.register(meterRegistry);
        
        
        System.out.println("Total count of books available- "+totalBooks.get());
                
    }

   
    public List<Book> findByTitle(String title) throws InterruptedException {
        Tag titleTag = Tag.of(MetricUtil.TAG_TITLE, MetricUtil.getTagTitle(title));
        List<Book> books;
        Timer.Sample timer = Timer.start(meterRegistry);

        if (StringUtils.isEmpty(title)) {
            Thread.sleep(ThreadLocalRandom.current().nextInt(100, 200));
            books  = BookMapper.maptoBookDTOList(booksRepository.findAll());
        } else {
            if ("FUNDAMENTAL ALGORITHMS".equalsIgnoreCase(title)) {
                Thread.sleep(ThreadLocalRandom.current().nextInt(1_000, 3_000));
            } else {
                Thread.sleep(ThreadLocalRandom.current().nextInt(100, 1_000));
            }
            Book book  = BookMapper.mapToBookDTO(booksRepository.findByTitle(title));
            books = new ArrayList<>();
            books.add(book);
        }

        timer.stop(Timer.builder(MetricUtil.METRIC_BOOKS_BY_TITLE_SEARCH)
            .description("Timer showing how long does it take to search for books")
            .tags(List.of(titleTag))
            .register(meterRegistry));

        return books;
    }

    
    public Book createBook(Book bookDto) {
		BooksEntity bookEntity = BookMapper.mapToBookEntity(bookDto);
		BooksEntity createdBook = booksRepository.save(bookEntity);
		return BookMapper.mapToBookDTO(createdBook);
	}
    
}